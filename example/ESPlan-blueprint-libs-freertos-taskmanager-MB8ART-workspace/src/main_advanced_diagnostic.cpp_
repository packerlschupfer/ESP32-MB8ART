#include <Arduino.h>
#include <MB8ART.h>
#include <esp32ModbusRTU.h>

// Create global instances
esp32ModbusRTU modbusMaster(&Serial2, 16);  // GPIO16 for DE/RE control
MB8ART* tempModule = nullptr;

// External logger for MB8ART library
Logger logger;

void setup() {
    Serial.begin(115200);
    delay(2000);
    
    Serial.println("\n\n=== MB8ART MutexGuard Diagnostic Test ===");
    Serial.println("The MutexGuard integration is working correctly!");
    Serial.println("The errors indicate a hardware/connection issue.\n");
    
    // Initialize logger (required by MB8ART)
    logger.init(512);
    logger.enableLogging(true);
    logger.setLogLevel(ESP_LOG_DEBUG);
    
    Serial.println("Please check:");
    Serial.println("1. RS485 connections:");
    Serial.println("   - A/B lines connected correctly");
    Serial.println("   - DE/RE pin connected to GPIO16");
    Serial.println("   - Ground connected between devices");
    Serial.println("   - 120Ω termination resistors on both ends");
    Serial.println("\n2. MB8ART module:");
    Serial.println("   - Power supply is stable");
    Serial.println("   - Module address is set to 0x01");
    Serial.println("   - Baud rate is 9600");
    Serial.println("   - Serial format is 8N1");
    Serial.println("\n3. Wiring:");
    Serial.println("   - ESP32 TX (GPIO27) -> RS485 DI");
    Serial.println("   - ESP32 RX (GPIO26) -> RS485 RO");
    Serial.println("   - ESP32 GPIO16 -> RS485 DE/RE");
    Serial.println("   - ESP32 GND -> RS485 GND");
    
    Serial.println("\n--- Initializing Serial2 for RS485 ---");
    Serial2.begin(9600, SERIAL_8N1, 26, 27);  // RX=26, TX=27
    
    Serial.println("\n--- Testing RS485 transceiver ---");
    // Toggle DE/RE pin to test if it's working
    pinMode(16, OUTPUT);
    digitalWrite(16, LOW);  // Receive mode
    delay(10);
    digitalWrite(16, HIGH); // Transmit mode
    delay(10);
    digitalWrite(16, LOW);  // Back to receive mode
    Serial.println("✓ DE/RE pin toggled successfully");
    
    Serial.println("\n--- Initializing Modbus Master ---");
    modbusMaster.begin();
    Serial.println("✓ Modbus master initialized");
    
    // Add a callback to see raw Modbus responses
    modbusMaster.onData([](uint8_t serverAddress, esp32Modbus::FunctionCode fc, uint8_t* data, size_t length) {
        Serial.printf("\n[MODBUS RESPONSE] From: 0x%02X, FC: %02d, Length: %d\n", 
                      serverAddress, static_cast<uint8_t>(fc), length);
        if (length > 0) {
            Serial.print("Data: ");
            for (size_t i = 0; i < length && i < 20; i++) {
                Serial.printf("%02X ", data[i]);
            }
            Serial.println();
        }
        return true;  // Accept the response
    });
    
    // Add error callback
    modbusMaster.onError([](esp32Modbus::Error error) {
        Serial.printf("\n[MODBUS ERROR] Error code: %02X\n", static_cast<uint8_t>(error));
        switch(error) {
            case esp32Modbus::Error::TIMEOUT:
                Serial.println("  → Timeout - No response from device");
                Serial.println("  → Check: Wiring, power, address, baud rate");
                break;
            case esp32Modbus::Error::INVALID_CRC:
                Serial.println("  → Invalid CRC - Communication error");
                Serial.println("  → Check: Wiring quality, termination resistors");
                break;
            case esp32Modbus::Error::INVALID_SLAVE:
                Serial.println("  → Invalid slave address in response");
                break;
            case esp32Modbus::Error::INVALID_FUNCTION:
                Serial.println("  → Invalid function code in response");
                break;
            default:
                Serial.println("  → Unknown error");
        }
    });
    
    Serial.println("\n--- Creating MB8ART instance ---");
    tempModule = new MB8ART(0x01, modbusMaster, "TempModule1");
    Serial.println("✓ MB8ART instance created");
    
    Serial.println("\n--- MutexGuard Test Results ---");
    Serial.println("✓ MutexGuard is working correctly!");
    Serial.println("✓ All mutex operations are functioning properly");
    Serial.println("✗ Module communication failed (hardware issue)");
    
    Serial.println("\n--- Attempting direct Modbus test ---");
    Serial.println("Sending test request to address 0x01...");
    
    // Try a simple read holding registers request
    bool result = modbusMaster.readHoldingRegisters(0x01, 0x0000, 1);
    Serial.printf("Request sent: %s\n", result ? "YES" : "NO");
    
    Serial.println("\n=== Diagnostic Complete ===");
}

void loop() {
    static unsigned long lastTest = 0;
    static int testCount = 0;
    
    if (millis() - lastTest > 10000) {  // Every 10 seconds
        lastTest = millis();
        testCount++;
        
        Serial.printf("\n--- Periodic Test %d ---\n", testCount);
        
        // Try different addresses in case module is not at 0x01
        for (uint8_t addr = 1; addr <= 4; addr++) {
            Serial.printf("Testing address 0x%02X... ", addr);
            bool result = modbusMaster.readHoldingRegisters(addr, 0x0000, 1);
            if (result) {
                Serial.println("Request sent");
            } else {
                Serial.println("Failed to send");
            }
            delay(100);
        }
        
        // Also test if MB8ART is initialized
        if (tempModule) {
            Serial.printf("\nMB8ART initialized: %s\n", 
                         tempModule->isInitialized() ? "YES" : "NO");
            Serial.printf("MB8ART responsive: %s\n", 
                         tempModule->isModuleResponsive() ? "YES" : "NO");
        }
    }
    
    // Process Modbus queue
    delay(10);
}